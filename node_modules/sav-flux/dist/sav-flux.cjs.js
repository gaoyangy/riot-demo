/*!
 * sav-flux v0.0.20
 * (c) 2017 jetiny 86287344@qq.com
 * Release under the MIT License.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var savUtil = require('sav-util');

class Request {
  constructor(opts) {
    this.opts = {
      baseUrl: '/',
      stripHeaders: true, // 不返回头部信息
      ajax: savUtil.ajax
    };
    this.invokeQueues = [this.invoke.bind(this)];
    this.invoker = null;
    savUtil.bindEvent(this);
    if (opts) {
      this.setOptions(opts);
    }
  }
  setOptions(opts) {
    this.opts = Object.assign({}, this.opts, { opts });
  }
  before(fn) {
    this.invoker = null;
    this.invokeQueues.unshift(fn);
  }
  after(fn) {
    this.invoker = null;
    this.invokeQueues.push(fn);
  }
  get(url, options) {
    return this.request(Object.assign({ method: 'GET', url }, options));
  }
  post(url, options) {
    return this.request(Object.assign({ method: 'POST', url }, options));
  }
  put(url, options) {
    return this.request(Object.assign({ method: 'PUT', url }, options));
  }
  patch(url, options) {
    return this.request(Object.assign({ method: 'PATCH', url }, options));
  }
  del(url, options) {
    return this.request(Object.assign({ method: 'DELETE', url }, options));
  }
  request(options) {
    options = Object.assign({
      url: '',
      headers: {}
    }, options);
    let { stripHeaders, baseUrl } = this.opts;
    if ('stripHeaders' in options) {
      stripHeaders = options.stripHeaders;
    }
    if (!/^(http(s?):)?\/\//i.test(options.url)) {
      options.url = baseUrl + options.url.replace(/^\//, '');
    }
    if (!this.invoker) {
      this.invoker = savUtil.compose(this.invokeQueues);
    }
    let { invoker } = this;
    let ctx = { request: options };
    let res = invoker(ctx).then(() => stripHeaders ? ctx.response.data : ctx.response);
    return res;
  }
  invoke(ctx, next) {
    return new Promise((resolve, reject) => {
      ctx.xhr = savUtil.ajax(ctx.request, (err, data, headers) => {
        if (err) {
          return reject(err);
        }
        try {
          ctx.response = {
            data,
            headers
          };
          this.emit('response', ctx);
        } catch (err) {
          return reject(err);
        }
        resolve();
      });
      this.emit('request', ctx);
    }).then(next);
  }
}

function Flux(opts = { strict: true }) {
  let flux = this;
  let prop = initProp(flux);
  prop('flux', flux);
  prop('prop', prop);
  prop('mutations', {});
  prop('actions', {});
  prop('proxys', {});
  prop('opts', opts);
  initUse(flux)([initUtil, savUtil.bindEvent, initPromise, initCloneThen, initState, initCommit, initDispatch, initProxy, initDeclare]);
}

function initProp(flux) {
  let prop = (key, value, opts = {}) => {
    opts.value = value;
    Object.defineProperty(flux, key, opts);
  };
  prop.get = (key, value, opts = {}) => {
    opts.get = value;
    Object.defineProperty(flux, key, opts);
  };
  return prop;
}

function initUse({ flux, prop }) {
  let use = (plugin, opts) => {
    if (Array.isArray(plugin)) {
      return plugin.forEach(plugin => {
        flux.use(plugin, opts);
      });
    }
    plugin(flux, opts);
  };
  prop('use', use);
  return use;
}

function initUtil({ prop, opts }) {
  prop('clone', savUtil.clone);
  prop('extend', savUtil.extend);
  prop('request', new Request());
  prop('opt', (name, defaultVal = null) => {
    return name in opts ? opts[name] : defaultVal;
  });
}

function initState({ prop, emit, cloneThen, clone: clone$$1, resolve }) {
  let state = {};
  prop.get('state', () => state, {
    set() {
      throw new Error('[flux] Use flux.replaceState() to explicit replace store state.');
    }
  });
  prop('getState', () => clone$$1(state));

  prop('replaceState', newState => {
    let stateStr = JSON.stringify(newState);
    newState = JSON.parse(stateStr);
    for (let x in state) {
      delete state[x];
    }
    for (let x in newState) {
      state[x] = newState[x];
    }
    return Promise.resolve(JSON.parse(stateStr)).then(cloneState => {
      emit('replace', cloneState);
      return cloneState;
    });
  });

  prop('updateState', (changedState, slice) => {
    if (typeof changedState !== 'object') {
      throw new Error('[flux] updateState require new state as object');
    }
    if (changedState !== state) {
      Object.keys(changedState).map(key => {
        state[key] = changedState[key];
      });
    }
    if (!slice) {
      return cloneThen(changedState).then(cloneState => {
        emit('update', cloneState);
        return cloneState;
      });
    }
    return resolve();
  });
}

function initCommit({ prop, flux, updateState, resolve }) {
  let commit = (type, payload) => {
    let { mutations } = flux;
    if (typeof type === 'object') {
      payload = type;
      type = type.type;
    }
    let entry = mutations[type];
    if (!entry) {
      throw new Error('[flux] unknown mutation : ' + type);
    }
    let state = flux.state;
    let ret = entry(flux, payload);
    let update = ret => {
      if (ret) {
        if (ret === state) {
          throw new Error('[flux] commit require new object rather than old state');
        }
        if (typeof ret !== 'object') {
          throw new Error('[flux] commit require new object');
        }
        return updateState(ret);
      }
      return resolve();
    };
    if (savUtil.isPromiseLike(ret)) {
      return ret.then(update);
    } else {
      return update(ret);
    }
  };
  prop('commit', flux.opts.noProxy ? commit : proxyApi(commit));
}

function initDispatch({ prop, flux, commit, resolve, reject, opts, cloneThen }) {
  let dispatch = (action, payload) => {
    let { actions, mutations, proxys } = flux;
    let entry = action in actions && actions[action] || action in mutations && function (_, payload) {
      return commit(action, payload);
    };
    if (!entry && proxys[action]) {
      entry = proxys[action];
    }
    if (!entry) {
      return reject('[flux] unknown action : ' + action);
    }
    let err, ret;
    try {
      ret = entry(flux, payload);
    } catch (e) {
      err = e;
    }
    if (err) {
      return reject(err);
    }
    if (!savUtil.isPromiseLike(ret)) {
      ret = resolve(ret);
    }
    // make copy
    return opts.strict ? ret.then(data => {
      if (Array.isArray(data) || typeof data === 'object') {
        if (data.__clone) {
          return resolve(data);
        }
        return cloneThen(data).then(newData => {
          Object.defineProperty(newData, '__clone', { value: true });
          return resolve(newData);
        });
      }
      return resolve(data);
    }) : ret;
  };
  prop('dispatch', flux.opts.noProxy ? dispatch : proxyApi(dispatch));
}

function initProxy({ prop, proxys }) {
  prop('proxy', (name, value) => {
    if (typeof name === 'object') {
      // batch mode
      for (let x in name) {
        if (value === null) {
          delete proxys[x];
        } else {
          proxys[x] = name[x];
        }
      }
    } else {
      // once mode
      if (value === null) {
        delete proxys[name];
      } else {
        proxys[name] = value;
      }
    }
  });
}

function initDeclare({ prop, flux, emit, commit, dispatch, updateState }) {
  let declare = mod => {
    if (!mod) {
      return;
    }
    if (Array.isArray(mod)) {
      return mod.forEach(declare);
    }
    if (mod.mutations) {
      for (let mutation in mod.mutations) {
        if (flux.mutations[mutation]) {
          throw new Error(`[flux] mutation exists: ${mutation}`);
        }
        flux.mutations[mutation] = mod.mutations[mutation];
        if (flux.opts.noProxy || !savUtil.probe.Proxy) {
          proxyFunction(commit, mutation);
          proxyFunction(dispatch, mutation);
        }
      }
    }
    if (mod.proxys) {
      for (let action in mod.proxys) {
        flux.proxys[action] = mod.proxys[action];
      }
    }
    if (mod.actions) {
      for (let action in mod.actions) {
        if (flux.actions[action]) {
          throw new Error(`[flux] action exists: ${action}`);
        }
        flux.actions[action] = mod.actions[action];
        if (flux.opts.noProxy || !savUtil.probe.Proxy) {
          proxyFunction(dispatch, action);
        }
      }
    }
    if (mod.state) {
      let states = flux.state;
      for (let state in mod.state) {
        if (state in states) {
          throw new Error(`[flux] state exists: ${state}`);
        }
      }
      updateState(mod.state, true);
    }
    emit('declare', mod);
  };
  prop('declare', declare);
}

function proxyFunction(target, name) {
  target[name] = payload => {
    return target(name, payload);
  };
}

function proxyApi(entry) {
  if (savUtil.probe.Proxy) {
    return new Proxy(entry, {
      get(target, name) {
        return payload => {
          return entry(name, payload);
        };
      }
    });
  }
  return entry;
}

function initPromise({ prop }) {
  let PROMISE = Promise;
  prop('resolve', PROMISE.resolve.bind(PROMISE));
  prop('reject', PROMISE.reject.bind(PROMISE));
  prop('all', PROMISE.all.bind(PROMISE));
  prop('then', fn => {
    return new PROMISE(fn);
  });
}

function initCloneThen({ prop, clone: clone$$1, resolve, then }) {
  if (!savUtil.probe.MessageChannel) {
    prop('cloneThen', value => {
      return resolve().then(() => resolve(clone$$1(value)));
    });
    return;
  }
  /* global MessageChannel */
  const channel = new MessageChannel();
  let maps = {};
  let idx = 0;
  let port2 = channel.port2;
  port2.start();
  port2.onmessage = ({ data: { key, value } }) => {
    const resolve = maps[key];
    resolve(value);
    delete maps[key];
  };
  prop('cloneThen', value => {
    return new Promise(resolve => {
      const key = idx++;
      maps[key] = resolve;
      try {
        channel.port1.postMessage({ key, value });
      } catch (err) {
        console.error('cloneThen.postMessage', err);
        delete maps[key];
        try {
          value = JSON.parse(JSON.stringify(value));
        } catch (err) {
          console.error('cloneThen.JSON', err);
          value = clone$$1(value);
        }
        return then(() => resolve(value));
      }
    });
  });
}

function normalizeMap(map) {
  return Array.isArray(map) ? map.map(key => {
    return {
      key: key,
      val: key
    };
  }) : Object.keys(map).map(key => {
    return {
      key: key,
      val: map[key]
    };
  });
}

// 深度比较复制
function testAndUpdateDepth(oldState, newState, isVueRoot, Vue) {
  Object.keys(newState).forEach(name => {
    if (!(name in oldState)) {
      // 新加入的属性
      return Vue.set(oldState, name, newState[name]);
    }
    // 旧的比较赋值
    const newValue = newState[name];
    const oldValue = oldState[name];

    if (savUtil.isObject(newValue)) {
      if (!savUtil.isObject(oldValue)) {
        // @TEST 类型不匹配, 直接赋值, 正常情况不应该这样
        Vue.delete(oldState, name);
        Vue.set(oldState, name, newValue);
      } else {
        // 继续深度比较赋值
        testAndUpdateDepth(oldState[name], newValue, false, Vue);
      }
    } else if (savUtil.isArray(newValue)) {
      if (!savUtil.isArray(oldValue)) {
        // @TEST 类型不匹配, 直接赋值, 正常情况不应该这样
        Vue.delete(oldState, name);
        Vue.set(oldState, name, newValue);

        // @todo 需要先删除
        // delete oldState[name]
        // const ob = oldState.__ob__
        // defineReactive(ob.value, name, newValue)
        // if (isVueRoot && ob) { // 必须再通知一下
        //   ob.dep.notify()
        // }
      } else {
        testAndUpdateArray(oldValue, newValue, Vue);
      }
    } else {
      // 简单类型
      if (oldState[name] !== newState[name]) {
        oldState[name] = newState[name];
      }
    }
  });
}

function testAndUpdateArray(oldValue, newValue, Vue) {
  const oldLen = oldValue.length;
  const newLen = newValue.length;

  if (oldLen > newLen) {
    // 多了删掉
    oldValue.splice(newLen, oldLen);
  } else if (oldLen < newLen) {
    // 少了补上
    while (oldValue.length < newLen) {
      oldValue.push(null);
    }
  }
  newValue.forEach((it, id) => {
    if (savUtil.isObject(it)) {
      if (!savUtil.isObject(oldValue[id])) {
        // @TEST 类型不匹配, 直接赋值, 正常情况不应该这样
        oldValue.splice(id, 1, it);
      } else {
        // 复制对象
        testAndUpdateDepth(oldValue[id], it, false, Vue);
      }
    } else if (savUtil.isArray(it)) {
      if (!savUtil.isArray(oldValue[id])) {
        // @TEST 类型不匹配, 直接赋值, 正常情况不应该这样
        oldValue.splice(id, 1, it);
      } else {
        testAndUpdateArray(oldValue[id], it, Vue);
      }
    } else {
      // 简单类型 直接赋值
      if (it !== oldValue[id]) {
        oldValue.splice(id, 1, it);
      }
    }
  });
}

function resetStoreVM(Vue, flux, vaf, state) {
  let oldVm = vaf.vm;
  if (oldVm) {
    flux.off('update', vaf.watch);
  }
  const silent = Vue.config.silent;
  Vue.config.silent = true;
  let vm = vaf.vm = new Vue({ data: { state } });
  flux.on('update', vaf.watch = newState => {
    if (vaf.deepCopy) {
      return testAndUpdateDepth(vm.state, newState, true, Vue);
    }
    if (isVmGetterMode) {
      let updates = [];
      for (let key in newState) {
        if (key in vm.state) {
          vm.state[key] = newState[key];
        } else {
          // dynamic computed methods
          Vue.util.defineReactive(vm.state, key, newState[key]);
          if (vmGetterMaps[key]) {
            vmGetterMaps[key].forEach(vmIt => {
              if (vmIt._computedWatchers && vmIt._computedWatchers[key]) {
                updates.indexOf(vmIt) === -1 && updates.push(vmIt);
                vmIt._computedWatchers[key].update();
              }
            });
          }
        }
      }
      updates.forEach(vm => vm.$forceUpdate());
    } else {
      // old version use mapGetters
      for (let key in newState) {
        vm.state[key] = newState[key];
      }
    }
  });
  Vue.config.silent = silent;
  if (oldVm) {
    oldVm.state = null;
    Vue.nextTick(() => oldVm.$destroy());
  }
}

let Vue;

function FluxVue({ flux, mixinActions = false, injects = [], router, onRouteFail, payload, deepth = -1, deepCopy = false }) {
  let vaf = {
    deepCopy,
    dispatch: flux.dispatch,
    proxy: flux.proxy
  };
  injects.forEach(key => {
    vaf[key] = flux[key];
  });
  resetStoreVM(Vue, flux, vaf, flux.getState());
  flux.on('replace', state => {
    resetStoreVM(Vue, flux, vaf, state);
  });
  if (mixinActions) {
    Vue.mixin({
      methods: mapActions(savUtil.unique(Object.keys(flux.mutations).concat(Object.keys(flux.actions))))
    });
  }
  Vue.mixin({
    methods: {
      dispatch(method, payload) {
        return vaf.dispatch(method, payload);
      }
    }
  });
  if (router) {
    router.beforeEach((to, from, next) => {
      let matchedComponents = router.getMatchedComponents(to);
      if (matchedComponents.length) {
        let arr = [];
        getComponentsDepth(Vue, matchedComponents, deepth, arr);
        let payloads = [];
        arr.reduce(processComponent, payloads);
        if (payloads.length) {
          let routes = getRoutes(to, router, payloads, flux);
          Promise.all(routes.map(({ path, query }) => {
            return flux.request.get({
              url: path,
              query
            });
          })).then(args => {
            let newState = Object.assign.apply({}, args);
            flux.updateState(newState);
            next();
          }).catch(err => {
            if (onRouteFail) {
              return onRouteFail(to, from, next, err);
            } else {
              next(false);
            }
          });
          return;
        }
      }
      next();
    });
  }
  return vaf;
}

let vmGetterMaps = {};
let isVmGetterMode = false;

function registerVmGetters(vm, getters) {
  isVmGetterMode || (isVmGetterMode = true);
  getters = vm._getters = Object.keys(getters);
  getters.forEach(key => {
    let arr = vmGetterMaps[key] || (vmGetterMaps[key] = []);
    arr.push(vm);
  });
}

function destroyVmGetters(vm) {
  if (vm._getters) {
    vm._getters.forEach(key => {
      if (vmGetterMaps[key]) {
        let arr = vmGetterMaps[key];
        let pos = arr.indexOf(vm);
        if (pos >= -1) {
          arr.splice(pos, 1);
        }
      }
    });
  }
}

FluxVue.install = function install(vue) {
  Vue = vue;
  Vue.mixin({
    beforeCreate() {
      const options = this.$options;
      if (options.vaf) {
        this.$flux = options.vaf;
      } else if (options.parent && options.parent.$flux) {
        this.$flux = options.parent.$flux;
      }
      let { proxys, methods, actions, getters, computed } = options;
      if (this.$flux) {
        if (actions) {
          methods || (methods = options.methods = {});
          Object.assign(methods, mapActions(actions));
        }
        if (getters) {
          computed || (computed = options.computed = {});
          let getterMaps = mapGetters(getters);
          registerVmGetters(this, getterMaps);
          Object.assign(computed, getterMaps);
        }
        if (proxys) {
          let maps = this.__vafMaps = {};
          Object.keys(proxys).map(key => {
            maps[key] = (typeof proxys[key] === 'function' ? proxys[key] : methods[proxys[key]]).bind(this);
          });
          this.$flux.proxy(maps);
        }
      }
    },
    beforeDestroy() {
      const options = this.$options;
      let { proxys } = options;
      if (proxys && this.$flux && this.__vafMaps) {
        this.$flux.proxy(this.__vafMaps, null);
      }
      if (isVmGetterMode) {
        destroyVmGetters(this);
      }
      if (this.$flux) {
        delete this.$flux;
      }
    }
  });
};

// 后续不建议使用
function mapGetters(getters) {
  let res = {};
  normalizeMap(getters).forEach(function (ref) {
    let key = ref.key;
    let val = ref.val;
    res[key] = savUtil.isFunction(val) ? function mappedGetter() {
      // function(state){}
      return val.call(this, this.$flux.vm.state);
    } : function mappedGetter() {
      return this.$flux.vm.state[val];
    };
  });
  return res;
}

function mapActions(actions) {
  let res = {};
  normalizeMap(actions).forEach(ref => {
    let key = ref.key;
    let val = ref.val;
    res[key] = function mappedAction(payload) {
      if (!this.$flux) {
        let message = `can not call action ${key} without flux`;
        return Promise.reject(new Error(message));
      }
      return this.$flux.dispatch(val, payload);
    };
  });
  return res;
}

function processComponent(payloads, component) {
  let options = typeof component === 'object' ? component : component.options;
  if (options.payload) {
    payloads.push(options.payload);
  }
  return payloads;
}

function getComponentsDepth(Vue, components, depth, arr) {
  if (Array.isArray(components)) {
    for (let i = 0; i < components.length; ++i) {
      appendComponent(Vue, components[i], depth, arr);
    }
  } else {
    for (let comName in components) {
      appendComponent(Vue, components[comName], depth, arr);
    }
  }
  return arr;
}

function appendComponent(Vue, com, depth, arr) {
  if (savUtil.isString(com)) {
    com = Vue.component(com);
  }
  if (com) {
    arr.push(com);
    if (depth && com.components) {
      getComponentsDepth(Vue, com.components, depth--, arr);
    }
  }
}

function getRoutes(vueRoute, vueRouter, payloads, flux) {
  let routes = payloads.reduce((routes, payload) => {
    if (savUtil.isFunction(payload)) {
      payload = payload(vueRoute);
    }
    if (Array.isArray(payload) || savUtil.isObject(payload)) {
      return routes.concat(payload);
    }
    return routes;
  }, []).map(route => {
    if (route.name && !route.fullPath) {
      return vueRouter.resolve(route);
    }
    return route;
  });
  return routes;
}

class FluxRedux {
  constructor({ flux }) {
    this.flux = flux;
    this.dispatch = flux.dispatch;
    this.state = flux.getState();
    flux.on('update', this.watchUpdate = newState => {
      this.state = Object.assign({}, this.state, newState);
      flux.emit('redux_change');
    });
    flux.on('replace', this.watchReplace = newState => {
      this.state = newState;
      flux.emit('redux_change');
    });
  }
  getState() {
    return this.state;
  }
  subscribe(fn) {
    return this.flux.subscribe('redux_change', fn);
  }
}

function FluxRiot({ flux, riot }) {
  let connect = {
    dispatch: flux.dispatch,
    state: flux.getState(),
    binds: {},
    binders: {}
  };
  flux.on('update', newState => {
    Object.assign(connect.state, newState);
    let ids = [];
    for (let name in newState) {
      ids = ids.concat(connect.binds[name]);
    }
    savUtil.unique(ids);
    let keys = Object.keys(newState);
    ids.forEach(tagName => {
      let binder = connect.binders[tagName];
      if (binder && binder.vms.length) {
        syncBinderKeys(binder, keys);
      }
    });
  });

  flux.on('replace', newState => {
    connect.state = newState;
    for (let tagName in connect.binders) {
      syncBinder(connect.binders[tagName]);
    }
  });

  riot.mixin({
    init: function () {
      this.on('before-mount', () => {
        if (this.getters) {
          let tagName = this.__.tagName;
          let binder;
          if (connect.binders[tagName]) {
            binder = connect.binders[tagName];
          } else {
            let getters = normalizeMap(this.getters);
            let sync = {};
            binder = {
              sync,
              keys: [],
              vms: []
            };
            connect.binders[tagName] = binder;
            getters.forEach(({ key, val }) => {
              let fn = savUtil.isFunction(val) ? () => {
                return val(connect.state);
              } : () => {
                return connect.state[key];
              };
              let binds = connect.binds[key] || (connect.binds[key] = []);
              binds.push(tagName);
              binder.keys.push(key);
              sync[key] = fn;
            });
          }
          this.on('unmount', () => {
            let idx = binder.vms.indexOf(this);
            if (idx >= 0) {
              binder.vms.splice(idx, 1);
            }
          });
          binder.vms.push(this);
          Object.assign(this, syncState(binder.keys, binder.sync));
        }
        if (this.actions) {
          normalizeMap(this.actions).forEach(({ key }) => {
            this[key] = payload => {
              return connect.dispatch(key, payload);
            };
          });
        }
      });
    }
  });
}

function syncState(keys, sync) {
  let ret = {};
  keys.forEach(key => {
    ret[key] = sync[key]();
  });
  return ret;
}

function syncBinder(binder) {
  if (binder.vms.length) {
    let state = syncState(binder.keys, binder.sync);
    binder.vms.forEach(vm => vm.update(state));
  }
}

function syncBinderKeys(binder, keys) {
  let state = syncState(keys.filter(key => binder.keys.indexOf(key) >= 0), binder.sync);
  binder.vms.forEach(vm => vm.update(state));
}

exports.Flux = Flux;
exports.FluxVue = FluxVue;
exports.mapGetters = mapGetters;
exports.mapActions = mapActions;
exports.FluxRedux = FluxRedux;
exports.FluxRiot = FluxRiot;
exports.Request = Request;
